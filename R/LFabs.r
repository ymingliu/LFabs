#' A Forward and Backward Stagewise algorithm for High-dimensional smoothed partial rank estimation with sparse laplacian shrinkage.
#'
#' The laplacian shrinkage level is fixed, which means \code{tau} is predetermined.
#' @param X The design matrix.
#' @param y The response.
#' @param s The status.
#' @param sigma The smoothing parameter in SPR.
#' @param weight The weight vector of adaptive lasso.
#' @param model The loss function. Quantitative for model="spr", model="cox", model="lm".
#' @param tau The turning parameter before the laplacian penalty. Default is 0.
#' @param stoping The indicator of whether to stop iteration when lambda is less than lambda.min.
#' @param eps The step size for updating coefficients. Default is 0.02.
#' @param xi The threshhold for LFabs.
#' @param iter The maximum number of outer-loop iterations allowed.
#' @param lambda.min The smallest value for lambda, as a stopping Criterion of the solution path.
#'
#' @return A list.
#' \itemize{
#'   \item Beta - The standardized estimator along the solution path.
#'   \item beta - The optimal standardized estimator.
#'   \item lambda - Lambda sequence generated by LFabs.
#'   \item direction - Direction of LFabs. \code{1} indicates a forward step. \code{0} indicates a backward step.
#'   \item active - Active set for each step.
#'   \item iter - Iterations.
#'   \item bic - The bic for each solution.
#'   \item opt - Position of the optimal lambda based on bic.
#' }
#' @export
#'
#' @examples
#' library(mvtnorm)
#' library(Matrix)
#'
#' n = 400
#' p = 500
#' d = 15
#' g = 5
#' sig = c(0.5, 1.5)
#' rho = 0.9
#' error = "contaminate"
#' tran = "log"
#' censor.rate = 0.1
#' block = "Auto"
#'
#' set.seed(2021)
#' dat = generator(n, p, d, g, sig, rho, error, tran, censor.rate, block)
#' x = dat$x
#' y = dat$y
#' status = dat$status
#'
#' sigma = 1/sqrt(n)
#' w = abs(1/drop(cor(x, y, method = "pearson")))
#' w[which(w=="NaN"|w=="Inf")] = max(w[which(w!="NaN"&w!="Inf")])
#' model = "spr"
#' tau = 0.5
#' fit <- LFabs(x, y, status, sigma, w, model, tau)

LFabs = function(X, y, s = NULL, sigma = NULL, weight = NULL, model=c("spr", "cox", "lm"), tau = 0,
                 stoping = TRUE, eps = 0.02, xi = 10^-6, iter = 10^4, lambda.min = 0.0001)
{
  x = as.matrix(X)
  n = nrow(x)
  p = ncol(x)
  max_s = as.integer(n/log(n))

  y.order   = order(y, decreasing = T)
  x = x[y.order, ]
  x     <- scale(x, center=TRUE, scale=TRUE)
  meanx <- attr(x, "scaled:center")
  sdx   <- attr(x, "scaled:scale")
  y = y[y.order]
  y     <- scale(y, center=TRUE, scale=FALSE)

  if (is.null(sigma))           sigma = 1/sqrt(n)
  if (is.null(lambda.min)) lambda.min = {if (n > p) 1e-4 else .02}
  if (is.null(weight))         weight = rep(1, p)
  if (is.null(s)) {
    s = rep(1, n)
  } else {
    s = s[y.order]
  }

  adj = adjmat(x)
  param = c(n, p, adj$ledge, 0, 0, 0, 1)

  model = match.arg(model)
  if (model == "spr") { is.loss = 0}
  if (model == "cox") { is.loss = 1; iter = 2*10^4 }
  if (model == "lm") { is.loss = 2; iter = 2*10^4 }

  bic.fit <- .Call("LFabs",
               as.numeric(y),
               as.numeric(t(x)),
               as.numeric(weight),
               as.integer(s),
               as.numeric(eps),
               as.numeric(lambda.min),
               as.numeric(sigma),
               as.numeric(xi),
               as.integer(stoping),
               as.integer(iter),
               as.integer(param),
               as.integer(is.loss),
               as.numeric(adj$edge),
               as.integer(adj$edgerow),
               as.integer(adj$edgecol),
               as.numeric(adj$gamma),
               as.integer(max_s),
               as.numeric(tau) )

  fit = bic.fit[[1]]
  fit$opt = which.min(bic.fit[[1]]$bic)
  theta <- sparseMatrix(fit$index_i, fit$index_j, x = fit$beta, dims = c(p, fit$iter), index1 = FALSE)

  val = list(Beta        = theta,
             beta        = theta[, fit$opt],
             lambda      = fit$lambda,
             direction   = fit$direction,
             active      = fit$active,
             iter        = fit$iter,
             bic         = fit$bic,
             opt         = fit$opt)

  return(val)
}




